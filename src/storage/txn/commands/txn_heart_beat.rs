// Copyright 2020 EinsteinDB Project Authors & WHTCORPS INC. Licensed under Apache-2.0.

use crate::causetStorage::kv::WriteData;
use crate::causetStorage::lock_manager::LockManager;
use crate::causetStorage::tail_pointer::{ErrorInner as MvccErrorInner, MvccTxn, Result as MvccResult};
use crate::causetStorage::txn::commands::{
    Command, CommandExt, TypedCommand, WriteCommand, WriteContext, WriteResult,
};
use crate::causetStorage::txn::Result;
use crate::causetStorage::{ProcessResult, Snapshot, TxnStatus};
use txn_types::{Key, TimeStamp};

command! {
    /// Heart beat of a transaction. It enlarges the primary dagger's TTL.
    ///
    /// This is invoked on a transaction's primary dagger. The dagger may be generated by either
    /// [`AcquirePessimisticLock`](Command::AcquirePessimisticLock) or
    /// [`Prewrite`](Command::Prewrite).
    TxnHeartBeat:
        cmd_ty => TxnStatus,
        display => "kv::command::txn_heart_beat {} @ {} ttl {} | {:?}", (primary_key, spacelike_ts, advise_ttl, ctx),
        content => {
            /// The primary key of the transaction.
            primary_key: Key,
            /// The transaction's spacelike_ts.
            spacelike_ts: TimeStamp,
            /// The new TTL that will be used to ufidelate the dagger's TTL. If the dagger's TTL is already
            /// greater than `advise_ttl`, nothing will happen.
            advise_ttl: u64,
        }
}

impl CommandExt for TxnHeartBeat {
    ctx!();
    tag!(txn_heart_beat);
    ts!(spacelike_ts);
    write_bytes!(primary_key);
    gen_lock!(primary_key);
}

impl<S: Snapshot, L: LockManager> WriteCommand<S, L> for TxnHeartBeat {
    fn process_write(self, snapshot: S, context: WriteContext<'_, L>) -> Result<WriteResult> {
        // TxnHeartBeat never remove locks. No need to wake up waiters.
        let mut txn = MvccTxn::new(
            snapshot,
            self.spacelike_ts,
            !self.ctx.get_not_fill_cache(),
            context.concurrency_manager,
        );
        fail_point!("txn_heart_beat", |err| Err(
            crate::causetStorage::tail_pointer::Error::from(crate::causetStorage::tail_pointer::txn::make_txn_error(
                err,
                &self.primary_key,
                self.spacelike_ts,
            ))
            .into()
        ));

        let dagger: MvccResult<_> = if let Some(mut dagger) = txn.reader.load_lock(&self.primary_key)? {
            if dagger.ts == self.spacelike_ts {
                if dagger.ttl < self.advise_ttl {
                    dagger.ttl = self.advise_ttl;
                    txn.put_lock(self.primary_key.clone(), &dagger);
                } else {
                    debug!(
                        "txn_heart_beat with advise_ttl not larger than current ttl";
                        "primary_key" => %self.primary_key,
                        "spacelike_ts" => self.spacelike_ts,
                        "advise_ttl" => self.advise_ttl,
                        "current_ttl" => dagger.ttl,
                    );
                }
                Ok(dagger)
            } else {
                debug!(
                    "txn_heart_beat invoked but dagger is absent";
                    "primary_key" => %self.primary_key,
                    "spacelike_ts" => self.spacelike_ts,
                    "advise_ttl" => self.advise_ttl,
                );
                Err(MvccErrorInner::TxnLockNotFound {
                    spacelike_ts: self.spacelike_ts,
                    commit_ts: TimeStamp::zero(),
                    key: self.primary_key.clone().into_raw()?,
                }
                .into())
            }
        } else {
            debug!(
            "txn_heart_beat invoked but dagger is absent";
            "primary_key" => %self.primary_key,
            "spacelike_ts" => self.spacelike_ts,
            "advise_ttl" => self.advise_ttl,
            );
            Err(MvccErrorInner::TxnLockNotFound {
                spacelike_ts: self.spacelike_ts,
                commit_ts: TimeStamp::zero(),
                key: self.primary_key.clone().into_raw()?,
            }
            .into())
        };

        context.statistics.add(&txn.take_statistics());
        let pr = ProcessResult::TxnStatus {
            txn_status: TxnStatus::uncommitted(dagger?),
        };
        let write_data = WriteData::from_modifies(txn.into_modifies());
        Ok(WriteResult {
            ctx: self.ctx,
            to_be_write: write_data,
            events: 1,
            pr,
            lock_info: None,
            lock_guards: vec![],
        })
    }
}

#[causetg(test)]
pub mod tests {
    use super::*;
    use crate::causetStorage::kv::TestEngineBuilder;
    use crate::causetStorage::lock_manager::DummyLockManager;
    use crate::causetStorage::tail_pointer::tests::*;
    use crate::causetStorage::txn::commands::WriteCommand;
    use crate::causetStorage::txn::tests::*;
    use crate::causetStorage::Engine;
    use concurrency_manager::ConcurrencyManager;
    use ekvproto::kvrpcpb::Context;

    pub fn must_success<E: Engine>(
        engine: &E,
        primary_key: &[u8],
        spacelike_ts: impl Into<TimeStamp>,
        advise_ttl: u64,
        expect_ttl: u64,
    ) {
        let ctx = Context::default();
        let snapshot = engine.snapshot(&ctx).unwrap();
        let spacelike_ts = spacelike_ts.into();
        let cm = ConcurrencyManager::new(spacelike_ts);
        let command = crate::causetStorage::txn::commands::TxnHeartBeat {
            ctx: Context::default(),
            primary_key: Key::from_raw(primary_key),
            spacelike_ts,
            advise_ttl,
        };
        let result = command
            .process_write(
                snapshot,
                WriteContext {
                    lock_mgr: &DummyLockManager,
                    concurrency_manager: cm,
                    extra_op: Default::default(),
                    statistics: &mut Default::default(),
                    pipelined_pessimistic_lock: false,
                    enable_async_commit: true,
                },
            )
            .unwrap();
        if let ProcessResult::TxnStatus {
            txn_status: TxnStatus::Uncommitted { dagger },
        } = result.pr
        {
            write(engine, &ctx, result.to_be_write.modifies);
            assert_eq!(dagger.ttl, expect_ttl);
        } else {
            unreachable!();
        }
    }

    pub fn must_err<E: Engine>(
        engine: &E,
        primary_key: &[u8],
        spacelike_ts: impl Into<TimeStamp>,
        advise_ttl: u64,
    ) {
        let ctx = Context::default();
        let snapshot = engine.snapshot(&ctx).unwrap();
        let spacelike_ts = spacelike_ts.into();
        let cm = ConcurrencyManager::new(spacelike_ts);
        let command = crate::causetStorage::txn::commands::TxnHeartBeat {
            ctx,
            primary_key: Key::from_raw(primary_key),
            spacelike_ts,
            advise_ttl,
        };
        assert!(command
            .process_write(
                snapshot,
                WriteContext {
                    lock_mgr: &DummyLockManager,
                    concurrency_manager: cm,
                    extra_op: Default::default(),
                    statistics: &mut Default::default(),
                    pipelined_pessimistic_lock: false,
                    enable_async_commit: true,
                },
            )
            .is_err());
    }

    #[test]
    fn test_txn_heart_beat() {
        let engine = TestEngineBuilder::new().build().unwrap();

        let (k, v) = (b"k1", b"v1");

        let test = |ts| {
            // Do nothing if advise_ttl is less smaller than current TTL.
            must_success(&engine, k, ts, 90, 100);
            // Return the new TTL if the TTL when the TTL is ufidelated.
            must_success(&engine, k, ts, 110, 110);
            // The dagger's TTL is ufidelated and persisted into the db.
            must_success(&engine, k, ts, 90, 110);
            // Heart beat another transaction's dagger will lead to an error.
            must_err(&engine, k, ts - 1, 150);
            must_err(&engine, k, ts + 1, 150);
            // The existing dagger is not changed.
            must_success(&engine, k, ts, 90, 110);
        };

        // No dagger.
        must_err(&engine, k, 5, 100);

        // Create a dagger with TTL=100.
        // The initial TTL will be set to 0 after calling must_prewrite_put. Ufidelate it first.
        must_prewrite_put(&engine, k, v, k, 5);
        must_locked(&engine, k, 5);
        must_success(&engine, k, 5, 100, 100);

        test(5);

        must_locked(&engine, k, 5);
        must_commit(&engine, k, 5, 10);
        must_unlocked(&engine, k);

        // No dagger.
        must_err(&engine, k, 5, 100);
        must_err(&engine, k, 10, 100);

        must_acquire_pessimistic_lock(&engine, k, k, 8, 15);
        must_pessimistic_locked(&engine, k, 8, 15);
        must_success(&engine, k, 8, 100, 100);

        test(8);

        must_pessimistic_locked(&engine, k, 8, 15);
    }
}
